<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>고양이 슈팅 게임</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: #000033;
            overflow: hidden;
        }
        #cat {
            width: 50px;
            height: 50px;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .obstacle {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #FF4136;
            border-radius: 50%;
            box-shadow: 0 0 10px #FF4136;
            z-index: 10;
        }
        .item {
            width: 20px;
            height: 20px;
            position: absolute;
            border-radius: 50%;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-family: Arial, sans-serif;
        }
        #characterSelect {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .catOption {
            width: 50px;
            height: 50px;
            margin: 0 10px;
            cursor: pointer;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border: 2px solid transparent;
        }
        .catOption:hover {
            border-color: white;
        }
        .catOption.selected {
            border-color: gold;
        }
        #gameControls, #gameOverScreen {
            display: none;
        }
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #scoreDisplay, #levelDisplay {
            position: absolute;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
        }
        #levelDisplay {
            top: 10px;
        }
        #scoreDisplay {
            top: 40px;
        }
        #gameControls {
            position: absolute;
            top: 10px;
            left: 10px;
        }
        .bullet {
            position: absolute;
            width: 5px;
            height: 10px;
            background-color: yellow;
        }
        #itemDescription {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #shield {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 2px solid yellow;
            box-shadow: 0 0 10px yellow;
            display: none;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <div id="cat"></div>
    <div id="shield"></div>
    <div id="levelDisplay">Level: 1</div>
    <div id="scoreDisplay">Score: 0</div>
    <div id="gameControls">
        <button id="pauseButton">일시정지</button>
        <button id="resumeButton" style="display: none;">계속하기</button>
    </div>
    <div id="itemDescription"></div>
    <div id="overlay">
        <div id="characterSelect">
            <div class="catOption" data-color="orange" style="background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZmlsbD0iI0ZGQTUwMCIgZD0iTTEwIDEwaDQ0djQ0SDEweiIvPjxjaXJjbGUgZmlsbD0iI0ZGRiIgY3g9IjI0IiBjeT0iMjQiIHI9IjgiLz48Y2lyY2xlIGZpbGw9IiNGRkYiIGN4PSI0MCIgY3k9IjI0IiByPSI4Ii8+PGNpcmxlIGZpbGw9IiMwMDAiIGN4PSIyNCIgY3k9IjI0IiByPSI0Ii8+PGNpcmxlIGZpbGw9IiMwMDAiIGN4PSI0MCIgY3k9IjI0IiByPSI0Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTE5LjUgMzloMjV2NEgxOS41eiIvPjwvc3ZnPg==');"></div>
            <div class="catOption" data-color="gray" style="background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZmlsbD0iIzgwODA4MCIgZD0iTTEwIDEwaDQ0djQ0SDEweiIvPjxjaXJjbGUgZmlsbD0iI0ZGRiIgY3g9IjI0IiBjeT0iMjQiIHI9IjgiLz48Y2lyY2xlIGZpbGw9IiNGRkYiIGN4PSI0MCIgY3k9IjI0IiByPSI4Ii8+PGNpcmNsZSBmaWxsPSIjMDAwIiBjeD0iMjQiIGN5PSIyNCIgcj0iNCIvPjxjaXJjbGUgZmlsbD0iIzAwMCIgY3g9IjQwIiBjeT0iMjQiIHI9IjQiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTkuNSAzOWgyNXY0SDE5LjV6Ii8+PC9zdmc+');"></div>
            <div class="catOption" data-color="white" style="background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZmlsbD0iI0ZGRkZGRiIgZD0iTTEwIDEwaDQ0djQ0SDEweiIvPjxjaXJjbGUgZmlsbD0iI0ZGQzBDQiIgY3g9IjI0IiBjeT0iMjQiIHI9IjgiLz48Y2lyY2xlIGZpbGw9IiNGRkMwQ0IiIGN4PSI0MCIgY3k9IjI0IiByPSI4Ii8+PGNpcmxlIGZpbGw9IiMwMDAiIGN4PSIyNCIgY3k9IjI0IiByPSI0Ii8+PGNpcmxlIGZpbGw9IiMwMDAiIGN4PSI0MCIgY3k9IjI0IiByPSI0Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTE5LjUgMzhoMjV2NEgxOS41eiIvPjwvc3ZnPg==');"></div>
            <div class="catOption" data-color="black" style="background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTEwIDEwaDQ0djQ0SDEweiIvPjxjaXJjbGUgZmlsbD0iI0ZGRiIgY3g9IjI0IiBjeT0iMjQiIHI9IjgiLz48Y2lyY2xlIGZpbGw9IiMwMDAiIGN4PSIyNCIgY3k9IjI0IiByPSI0Ii8+PGNpcmxlIGZpbGw9IiMwMDAiIGN4PSI0MCIgY3k9IjI0IiByPSI0Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTE5LjUgMzhoMjV2NEgxOS41eiIvPjwvc3ZnPg==');"></div>
        </div>
        <button id="startButton">게임 시작</button>
    </div>
    <div id="gameOverScreen">
        <h2>게임 오버!</h2>
        <p id="finalScore">최종 점수: 0</p>
        <button id="restartButton">다시 시작</button>
    </div>
</div>
<script>
    const gameContainer = document.getElementById('gameContainer');
    const cat = document.getElementById('cat');
    const shield = document.getElementById('shield');
    const overlay = document.getElementById('overlay');
    const characterSelect = document.getElementById('characterSelect');
    const startButton = document.getElementById('startButton');
    const gameControls = document.getElementById('gameControls');
    const pauseButton = document.getElementById('pauseButton');
    const resumeButton = document.getElementById('resumeButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const itemDescription = document.getElementById('itemDescription');

    let gameLoop;
    let score = 0;
    let level = 1;
    let gameTime = 0;
    let isGameActive = false;
    let isPaused = false;
    let obstacles = [];
    let items = [];
    let bullets = [];

    class Player {
        constructor() {
            this.speed = 5;
            this.isInvincible = false;
            this.moveDirection = 0;
            this.shootCooldown = 0;
            this.position = gameContainer.clientWidth / 2;
        }

        move() {
            this.position += this.moveDirection * this.speed;
            this.position = Math.max(25, Math.min(this.position, gameContainer.clientWidth - 25));
            cat.style.left = `${this.position}px`;
            this.updateShieldPosition();
        }

        updateShieldPosition() {
            const catRect = cat.getBoundingClientRect();
            shield.style.left = `${this.position - 35}px`;  // 70px / 2 = 35px
            shield.style.bottom = `${gameContainer.clientHeight - catRect.bottom - 10}px`;
        }

        shoot() {
            if (this.shootCooldown <= 0) {
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                bullet.style.left = `${parseInt(cat.style.left) + cat.clientWidth / 2 - 2.5}px`;
                bullet.style.bottom = `${cat.clientHeight}px`;
                gameContainer.appendChild(bullet);
                bullets.push(bullet);
                this.shootCooldown = 20;
            }
        }

        updateBullets() {
            bullets.forEach((bullet, index) => {
                const bottom = parseInt(bullet.style.bottom) || 0;
                if (bottom > gameContainer.clientHeight) {
                    gameContainer.removeChild(bullet);
                    bullets.splice(index, 1);
                } else {
                    bullet.style.bottom = `${bottom + 10}px`;
                }
            });
            if (this.shootCooldown > 0) this.shootCooldown--;
        }
    }

    const player = new Player();

    const itemTypes = [
        { type: 'speedBoost', color: 'blue', description: '속도 증가: 3초간 이동 속도 증가' },
        { type: 'shield', color: 'yellow', description: '방어막: 3초간 무적' },
        { type: 'doubleScore', color: 'purple', description: '더블 스코어: 10초간 점수 2배' },
        { type: 'multiShot', color: 'orange', description: '멀티샷: 5초간 3발 동시 발사' }
    ];

    function spawnObstacle() {
        const obstacle = document.createElement('div');
        obstacle.className = 'obstacle';
        obstacle.style.left = `${Math.random() * (gameContainer.clientWidth - 40)}px`;
        obstacle.style.top = '0px';
        gameContainer.appendChild(obstacle);
        obstacles.push(obstacle);
    }

    function updateObstacles() {
        obstacles.forEach((obstacle, index) => {
            const top = parseInt(obstacle.style.top) || 0;
            if (top > gameContainer.clientHeight) {
                gameContainer.removeChild(obstacle);
                obstacles.splice(index, 1);
            } else {
                obstacle.style.top = `${top + 2}px`;
            }
        });
    }

    function spawnItem() {
        const item = document.createElement('div');
        const randomItem = itemTypes[Math.floor(Math.random() * itemTypes.length)];
        item.className = 'item';
        item.dataset.type = randomItem.type;
        item.style.backgroundColor = randomItem.color;
        item.style.left = `${Math.random() * (gameContainer.clientWidth - 20)}px`;
        item.style.top = '0px';
        gameContainer.appendChild(item);
        items.push(item);
    }

    function updateItems() {
        items.forEach((item, index) => {
            const top = parseInt(item.style.top) || 0;
            if (top > gameContainer.clientHeight) {
                gameContainer.removeChild(item);
                items.splice(index, 1);
            } else {
                item.style.top = `${top + 1}px`;
            }
        });
    }

    function checkCollision(element1, element2) {
        const rect1 = element1.getBoundingClientRect();
        const rect2 = element2.getBoundingClientRect();
        return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
    }

    function applyItemEffect(type) {
        const descriptionElement = document.getElementById('itemDescription');
        switch(type) {
            case 'speedBoost':
                player.speed *= 2;
                setTimeout(() => player.speed /= 2, 3000);
                descriptionElement.textContent = '속도 증가 활성화!';
                break;
            case 'shield':
                player.isInvincible = true;
                shield.style.display = 'block';
                player.updateShieldPosition();
                setTimeout(() => {
                    player.isInvincible = false;
                    shield.style.display = 'none';
                }, 3000);
                descriptionElement.textContent = '방어막 활성화!';
                break;
            case 'doubleScore':
                let originalScoreIncrement = 1;
                score += 1;
                setTimeout(() => score += 1, 10000);
                descriptionElement.textContent = '더블 스코어 활성화!';
                break;
            case 'multiShot':
                let originalShoot = player.shoot;
                player.shoot = function() {
                    for(let i = -1; i <= 1; i++) {
                        const bullet = document.createElement('div');
                        bullet.className = 'bullet';
                        bullet.style.left = `${parseInt(cat.style.left) + cat.clientWidth / 2 - 2.5 + i * 10}px`;
                        bullet.style.bottom = `${cat.clientHeight}px`;
                        gameContainer.appendChild(bullet);
                        bullets.push(bullet);
                    }
                };
                setTimeout(() => player.shoot = originalShoot, 5000);
                descriptionElement.textContent = '멀티샷 활성화!';
                break;
        }
        setTimeout(() => descriptionElement.textContent = '', 3000);
    }

    function updateScore() {
        scoreDisplay.textContent = `Score: ${score}`;
    }

    function updateLevel() {
        level = Math.floor(score / 1000) + 1;
        levelDisplay.textContent = `Level: ${level}`;
        player.speed = 5 + (level - 1) * 0.5;
    }

    function gameOver() {
        isGameActive = false;
        cancelAnimationFrame(gameLoop);
        finalScore.textContent = `최종 점수: ${score}`;
        gameOverScreen.style.display = 'flex';
    }

    function resetGame() {
        isGameActive = false;
        isPaused = false;
        cancelAnimationFrame(gameLoop);
        gameOverScreen.style.display = 'none';
        overlay.style.display = 'flex';
        gameControls.style.display = 'none';
        scoreDisplay.style.display = 'none';
        levelDisplay.style.display = 'none';
        cat.style.left = '50%';
        score = 0;
        level = 1;
        gameTime = 0;
        player.moveDirection = 0;
        obstacles.forEach(obstacle => gameContainer.removeChild(obstacle));
        items.forEach(item => gameContainer.removeChild(item));
        bullets.forEach(bullet => gameContainer.removeChild(bullet));
        obstacles = [];
        items = [];
        bullets = [];
        updateScore();
        updateLevel();
    }

    function startGame() {
        if (!characterSelect.querySelector('.selected')) {
            alert("캐릭터를 선택하세요.");
            return;
        }

        isGameActive = true;
        isPaused = false;
        overlay.style.display = 'none';
        gameControls.style.display = 'block';
        scoreDisplay.style.display = 'block';
        levelDisplay.style.display = 'block';
        score = 0;
        level = 1;
        gameTime = 0;
        updateScore();
        updateLevel();

        player.position = gameContainer.clientWidth / 2;
        cat.style.left = `${player.position}px`;

        gameLoop = requestAnimationFrame(gameLoopFunction);
    }

    function pauseGame() {
        if (isGameActive) {
            isPaused = true;
            pauseButton.style.display = 'none';
            resumeButton.style.display = 'inline-block';
        }
    }

    function resumeGame() {
        if (isGameActive) {
            isPaused = false;
            pauseButton.style.display = 'inline-block';
            resumeButton.style.display = 'none';
            gameLoop = requestAnimationFrame(gameLoopFunction);
        }
    }

    function gameLoopFunction() {
        if (!isGameActive) return;

        if (isPaused) {
            gameLoop = requestAnimationFrame(gameLoopFunction);
            return;
        }

        gameTime++;

        player.move();
        player.updateBullets();

        if (gameTime % 60 === 0) {
            score++;
            updateScore();
            updateLevel();
        }

        if (gameTime % 120 === 0) {
            spawnObstacle();
        }

        if (gameTime % 180 === 0) {
            spawnItem();
        }

        updateObstacles();
        updateItems();

        obstacles.forEach((obstacle, index) => {
            if (checkCollision(cat, obstacle) && !player.isInvincible) {
                gameOver();
                return;
            }
            bullets.forEach((bullet, bulletIndex) => {
                if (checkCollision(bullet, obstacle)) {
                    gameContainer.removeChild(bullet);
                    gameContainer.removeChild(obstacle);
                    bullets.splice(bulletIndex, 1);
                    obstacles.splice(index, 1);
                    score += 10;
                    updateScore();
                }
            });
        });

        items.forEach((item, index) => {
            if (checkCollision(cat, item)) {
                applyItemEffect(item.dataset.type);
                gameContainer.removeChild(item);
                items.splice(index, 1);
                score += 50;
                updateScore();
            }
        });

        gameLoop = requestAnimationFrame(gameLoopFunction);
    }

    startButton.addEventListener('click', startGame);
    pauseButton.addEventListener('click', pauseGame);
    resumeButton.addEventListener('click', resumeGame);
    restartButton.addEventListener('click', () => {
        resetGame();
        startGame();
    });

    document.addEventListener('keydown', (e) => {
        if (!isGameActive) return;

        if (e.key === 'ArrowLeft') {
            player.moveDirection = -1;
        } else if (e.key === 'ArrowRight') {
            player.moveDirection = 1;
        } else if (e.key === ' ' || e.key === 'ArrowUp') {
            player.shoot();
        }
    });

    document.addEventListener('keyup', (e) => {
        if (!isGameActive) return;

        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            player.moveDirection = 0;
        }
    });

    // 모바일 터치 이벤트
    let touchStartX = 0;
    gameContainer.addEventListener('touchstart', (e) => {
        if (!isGameActive) return;
        touchStartX = e.touches[0].clientX;
    });

    gameContainer.addEventListener('touchmove', (e) => {
        if (!isGameActive) return;
        const touchEndX = e.touches[0].clientX;
        const diff = touchEndX - touchStartX;
        if (Math.abs(diff) > 10) {
            player.moveDirection = Math.sign(diff);
            touchStartX = touchEndX;
        }
    });

    gameContainer.addEventListener('touchend', () => {
        if (!isGameActive) return;
        player.moveDirection = 0;
    });

    characterSelect.addEventListener('click', (e) => {
        if (e.target.classList.contains('catOption')) {
            const previousSelected = characterSelect.querySelector('.selected');
            if (previousSelected) {
                previousSelected.classList.remove('selected');
            }
            e.target.classList.add('selected');
            cat.style.backgroundImage = e.target.style.backgroundImage;
        }
    });
</script>
</body>
</html>
